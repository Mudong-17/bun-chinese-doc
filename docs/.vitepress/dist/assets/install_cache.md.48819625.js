import{_ as s,o as a,c as e,Q as n}from"./chunks/framework.33544f09.js";const m=JSON.parse('{"title":"Global cache","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"install/cache.md","filePath":"install/cache.md"}'),o={name:"install/cache.md"},l=n(`<h1 id="global-cache" tabindex="-1">Global cache <a class="header-anchor" href="#global-cache" aria-label="Permalink to &quot;Global cache&quot;">​</a></h1><p>所有从注册表下载的包都存储在全局缓存中，位于 <code>~/.bun/install/cache</code>。它们存储在子目录中，名称类似于 <code>\${name}@\${version}</code>，因此可以缓存多个版本的包。</p><details><summary>配置缓存行为</summary><div class="language-toml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">toml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[</span><span style="color:#B392F0;">install</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">cache</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#6A737D;"># 用于缓存的目录</span></span>
<span class="line"><span style="color:#E1E4E8;">dir = </span><span style="color:#9ECBFF;">&quot;~/.bun/install/cache&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 当为true时，不从全局缓存中加载。</span></span>
<span class="line"><span style="color:#6A737D;"># Bun 仍可能写入 node_modules/.cache</span></span>
<span class="line"><span style="color:#E1E4E8;">disable = </span><span style="color:#79B8FF;">false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 当为true时，总是从注册表中解析最新版本</span></span>
<span class="line"><span style="color:#E1E4E8;">disableManifest = </span><span style="color:#79B8FF;">false</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[</span><span style="color:#6F42C1;">install</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">cache</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#6A737D;"># 用于缓存的目录</span></span>
<span class="line"><span style="color:#24292E;">dir = </span><span style="color:#032F62;">&quot;~/.bun/install/cache&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 当为true时，不从全局缓存中加载。</span></span>
<span class="line"><span style="color:#6A737D;"># Bun 仍可能写入 node_modules/.cache</span></span>
<span class="line"><span style="color:#24292E;">disable = </span><span style="color:#005CC5;">false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 当为true时，总是从注册表中解析最新版本</span></span>
<span class="line"><span style="color:#24292E;">disableManifest = </span><span style="color:#005CC5;">false</span></span></code></pre></div></details><h2 id="最小化重新下载" tabindex="-1">最小化重新下载 <a class="header-anchor" href="#最小化重新下载" aria-label="Permalink to &quot;最小化重新下载&quot;">​</a></h2><p>Bun 努力避免多次重新下载包。在安装包时，如果缓存中已经包含了<code>package.json</code>指定范围内的版本，Bun 将使用缓存的包，而不是再次下载它。</p><details><summary>安装详细信息</summary> 如果 semver 版本具有预发行后缀 (\`1.0.0-beta.0\`) 或构建后缀 (\`1.0.0+20220101\`)，它会被替换为该值的哈希值，以减少与长文件路径相关的错误的机会。 <p>当存在 <code>node_modules</code> 文件夹时，在安装之前，Bun 会检查 <code>node_modules</code> 是否包含所有预期包及其适当版本。如果是这样，<code>bun install</code> 完成。Bun 使用自定义 JSON 解析器，一旦找到<code>&quot;name&quot;</code>和<code>&quot;version&quot;</code>，它就停止解析。</p><p>如果缺少一个包或其版本与 <code>package.json</code> 不兼容，Bun 会检查缓存中是否有一个兼容的模块。如果找到，它将安装到 <code>node_modules</code> 中。否则，将从注册表下载该包，然后进行安装。</p></details><h2 id="快速复制" tabindex="-1">快速复制 <a class="header-anchor" href="#快速复制" aria-label="Permalink to &quot;快速复制&quot;">​</a></h2><p>一旦包被下载到缓存中，Bun 仍然需要将这些文件复制到 <code>node_modules</code> 中。Bun 使用可用的最快系统调用来执行此任务。在 Linux 上，它使用硬链接；在 macOS 上，它使用 <code>clonefile</code>。</p><h2 id="节省磁盘空间" tabindex="-1">节省磁盘空间 <a class="header-anchor" href="#节省磁盘空间" aria-label="Permalink to &quot;节省磁盘空间&quot;">​</a></h2><p>由于 Bun 在 Linux 上使用硬链接将模块“复制”到项目的 <code>node_modules</code> 目录中，所以包的内容只存在于磁盘上的一个位置，大大减少了专用于 <code>node_modules</code> 的磁盘空间量。</p><p>这个好处在性能原因上不适用于 macOS，macOS 出于性能原因使用 <code>clonefile</code>。</p><details><summary>安装策略</summary> 此行为可以通过 \`--backend\` 标志进行配置，该标志由 Bun 的所有包管理命令所尊重。 <ul><li><strong><code>hardlink</code></strong>：Linux 上的默认值。</li><li><strong><code>clonefile</code></strong>：macOS 上的默认值。</li><li><strong><code>clonefile_each_dir</code></strong>：与 <code>clonefile</code> 类似，但是它会为每个目录单独克隆每个文件。它仅在 macOS 上可用，性能比 <code>clonefile</code> 慢。</li><li><strong><code>copyfile</code></strong>：当上述任何一个失败时使用的后备选项。在 macOS 上，它使用 <code>fcopyfile()</code>；在 Linux 上，它使用 <code>copy_file_range()</code>。</li><li><strong><code>symlink</code></strong>：目前只用于 <code>file:</code>（以及最终 <code>link:</code>）依赖项。为防止无限循环，它跳过了 <code>node_modules</code> 文件夹的符号链接。</li></ul><p>如果使用 <code>--backend=symlink</code> 进行安装，Node.js 在依赖项的 node_modules 中不会解析 node_modules，除非每个依赖项都有自己的 <code>node_modules</code> 文件夹，或者您向 <code>node</code> 传递 <code>--preserve-symlinks</code>。请参阅 [Node.js 对 <code>--preserve-symlinks</code> 的文档](<a href="https://nodejs.org" target="_blank" rel="noreferrer">https://nodejs.org</a></p><p>/api/cli.html#--preserve-symlinks)。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">install</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--backend</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">symlink</span></span>
<span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">node</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--preserve-symlinks</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">./foo.js</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">install</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--backend</span><span style="color:#24292E;"> </span><span style="color:#032F62;">symlink</span></span>
<span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">node</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--preserve-symlinks</span><span style="color:#24292E;"> </span><span style="color:#032F62;">./foo.js</span></span></code></pre></div><p>Bun 的运行时目前尚未公开类似于 <code>--preserve-symlinks</code> 的等效功能。</p></details>`,12),c=[l];function p(t,d,r,i,y,u){return a(),e("div",null,c)}const E=s(o,[["render",p]]);export{m as __pageData,E as default};
