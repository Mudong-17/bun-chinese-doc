import{_ as s,o,c as a,Q as n}from"./chunks/framework.33544f09.js";const u=JSON.parse('{"title":"Loaders","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"bundler/loaders.md","filePath":"bundler/loaders.md"}'),l={name:"bundler/loaders.md"},p=n(`<h1 id="loaders" tabindex="-1">Loaders <a class="header-anchor" href="#loaders" aria-label="Permalink to &quot;Loaders&quot;">​</a></h1><p>Bun 打包工具实现了一组默认的加载器，可以直接使用。通常情况下，Bun 打包工具和运行时都默认支持相同的文件类型。</p><p>以下是 Bun 打包工具支持的默认文件类型列表：</p><ul><li><code>.js</code></li><li><code>.cjs</code></li><li><code>.mjs</code></li><li><code>.mts</code></li><li><code>.cts</code></li><li><code>.ts</code></li><li><code>.tsx</code></li><li><code>.jsx</code></li><li><code>.toml</code></li><li><code>.json</code></li><li><code>.txt</code></li><li><code>.wasm</code></li><li><code>.node</code></li></ul><p>Bun 使用文件扩展名来确定应使用哪个内置加载器（loader）来解析文件。每个加载器都有一个名称，例如<code>js</code>、<code>tsx</code>或<code>json</code>。这些名称在构建<a href="/bundler/plugins.html">插件</a>时用于扩展 Bun 并添加自定义加载器。</p><p>以下是内置加载器的详细信息：</p><h3 id="js" tabindex="-1"><code>js</code> <a class="header-anchor" href="#js" aria-label="Permalink to &quot;\`js\`&quot;">​</a></h3><p><strong>JavaScript 加载器</strong>。默认用于<code>.cjs</code>和<code>.mjs</code>文件。</p><p>解析代码并应用一组默认的转换，例如死代码消除、树抖动和内联环境变量。请注意，目前 Bun 不会尝试降级转换的语法。</p><h3 id="jsx" tabindex="-1"><code>jsx</code> <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;\`jsx\`&quot;">​</a></h3><p><strong>JavaScript + JSX 加载器</strong>。默认用于<code>.js</code>和<code>.jsx</code>文件。</p><p>与<code>js</code>加载器相同，但支持 JSX 语法。默认情况下，JSX 将被降级为纯 JavaScript；具体的降级方式取决于您的<code>tsconfig.json</code>中的<code>jsx*</code>编译器选项。有关更多信息，请参阅 TypeScript 文档中的<a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="noreferrer">JSX 部分</a>。</p><h3 id="ts" tabindex="-1"><code>ts</code> <a class="header-anchor" href="#ts" aria-label="Permalink to &quot;\`ts\`&quot;">​</a></h3><p><strong>TypeScript 加载器</strong>。默认用于<code>.ts</code>、<code>.mts</code>和<code>.cts</code>文件。</p><p>删除所有 TypeScript 语法，然后与<code>js</code>加载器表现相同。Bun 不执行类型检查。</p><h3 id="tsx" tabindex="-1"><code>tsx</code> <a class="header-anchor" href="#tsx" aria-label="Permalink to &quot;\`tsx\`&quot;">​</a></h3><p><strong>TypeScript + JSX 加载器</strong>。默认用于<code>.tsx</code>文件。将 TypeScript 和 JSX 都转译为纯粹的 JavaScript。</p><h3 id="json" tabindex="-1"><code>json</code> <a class="header-anchor" href="#json" aria-label="Permalink to &quot;\`json\`&quot;">​</a></h3><p><strong>JSON 加载器</strong>。默认用于<code>.json</code>文件。</p><p>可以直接导入 JSON 文件。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> pkg </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;./package.json&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">pkg.name; </span><span style="color:#6A737D;">// =&gt; &quot;my-package&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> pkg </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;./package.json&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">pkg.name; </span><span style="color:#6A737D;">// =&gt; &quot;my-package&quot;</span></span></code></pre></div><p>在打包过程中，解析的 JSON 将作为 JavaScript 对象内联到捆绑包中。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> pkg </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  name: </span><span style="color:#9ECBFF;">&quot;my-package&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ... 其他字段</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#E1E4E8;">pkg.name;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> pkg </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;my-package&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ... 其他字段</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#24292E;">pkg.name;</span></span></code></pre></div><p>如果将<code>.json</code>文件作为入口点传递给打包工具，它将被转换为一个<code>.js</code>模块，该模块将解析的对象导出为默认值。</p><h3 id="toml" tabindex="-1"><code>toml</code> <a class="header-anchor" href="#toml" aria-label="Permalink to &quot;\`toml\`&quot;">​</a></h3><p><strong>TOML 加载器</strong>。默认用于<code>.toml</code>文件。</p><p>可以直接导入 TOML 文件。Bun 将使用其快速的本机 TOML 解析器解析它们。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> config </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;./bunfig.toml&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">config.logLevel; </span><span style="color:#6A737D;">// =&gt; &quot;debug&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> config </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;./bunfig.toml&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">config.logLevel; </span><span style="color:#6A737D;">// =&gt; &quot;debug&quot;</span></span></code></pre></div><p>在打包过程中，解析的 TOML 将作为 JavaScript 对象内联到捆绑包中。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> config </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  logLevel: </span><span style="color:#9ECBFF;">&quot;debug&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ... 其他字段</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#E1E4E8;">config.logLevel;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> config </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  logLevel: </span><span style="color:#032F62;">&quot;debug&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ... 其他字段</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#24292E;">config.logLevel;</span></span></code></pre></div><p>如果将<code>.toml</code>文件作为入口点传递，它将被转换为一个<code>.js</code>模块，该模块将解析的对象导出为默认值。</p><h3 id="text" tabindex="-1"><code>text</code> <a class="header-anchor" href="#text" aria-label="Permalink to &quot;\`text\`&quot;">​</a></h3><p><strong>文本加载器</strong>。默认用于<code>.txt</code>文件。</p><p>文本文件的内容将被读取并内联到捆绑包中作为字符串。 文本文件可以直接导入。文件将被读取并作为字符串返回。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> contents </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;./file.txt&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(contents); </span><span style="color:#6A737D;">// =&gt; &quot;Hello, world!&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> contents </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;./file.txt&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(contents); </span><span style="color:#6A737D;">// =&gt; &quot;Hello, world!&quot;</span></span></code></pre></div><p>在构建过程中，文件的内容将内联到捆绑包中作为字符串。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> contents </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">\`Hello, world!\`</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(contents);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> contents </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">\`Hello, world!\`</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(contents);</span></span></code></pre></div><p>如果将<code>.txt</code>文件作为入口点传递，它将被转换为一个<code>.js</code>模块，该模块将文件内容导出为默认值。</p><h3 id="wasm" tabindex="-1"><code>wasm</code> <a class="header-anchor" href="#wasm" aria-label="Permalink to &quot;\`wasm\`&quot;">​</a></h3><p><strong>WebAssembly 加载器</strong>。默认用于<code>.wasm</code>文件。</p><p>在运行时，可以直接导入 WebAssembly 文件。该文件将被读取并返回为<code>WebAssembly.Module</code>。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> wasm </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;./module.wasm&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(wasm); </span><span style="color:#6A737D;">// =&gt; WebAssembly.Module</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> wasm </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;./module.wasm&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(wasm); </span><span style="color:#6A737D;">// =&gt; WebAssembly.Module</span></span></code></pre></div><p>在打包工具中，<code>.wasm</code>文件将使用<a href="#file"><code>file</code></a>加载器处理。</p><h3 id="napi" tabindex="-1"><code>napi</code> <a class="header-anchor" href="#napi" aria-label="Permalink to &quot;\`napi\`&quot;">​</a></h3><p><strong>本机插件加载器</strong>。默认用于<code>.node</code>文件。</p><p>在运行时，可以直接导入本机插件。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> addon </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;./addon.node&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(addon);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> addon </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;./addon.node&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(addon);</span></span></code></pre></div><p>在打包工具中，<code>.node</code>文件将使用<a href="#file"><code>file</code></a>加载器处理。</p><h3 id="file" tabindex="-1"><code>file</code> <a class="header-anchor" href="#file" aria-label="Permalink to &quot;\`file\`&quot;">​</a></h3><p><strong>文件加载器</strong>。默认用于所有未识别的文件类型。</p><p>文件加载器将导入解析为到导入的文件的<em>路径/URL</em>。通常用于引用媒体或字体资源。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">#logo.ts</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> logo </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;./logo.svg&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(logo);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">#logo.ts</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> logo </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;./logo.svg&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(logo);</span></span></code></pre></div><p><em>在运行时</em>，Bun 检查<code>logo.svg</code>文件是否存在，并将其转换为<code>logo.svg</code>在磁盘上的位置的绝对路径。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">bun</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">run</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">logo.ts</span></span>
<span class="line"><span style="color:#B392F0;">/path/to/project/logo.svg</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">bun</span><span style="color:#24292E;"> </span><span style="color:#032F62;">run</span><span style="color:#24292E;"> </span><span style="color:#032F62;">logo.ts</span></span>
<span class="line"><span style="color:#6F42C1;">/path/to/project/logo.svg</span></span></code></pre></div><p><em>在打包工具中</em>，情况稍有不同。文件将按原样复制到<code>outdir</code>，并且导入将解析为指向复制文件的相对路径。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">#Output</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> logo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;./logo.svg&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(logo);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">#Output</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> logo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;./logo.svg&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(logo);</span></span></code></pre></div><p>如果为<code>publicPath</code>指定了值，导入将使用该值作为前缀来构建绝对路径/URL。</p><table><thead><tr><th>公共路径（public path）</th><th>已解析的导入</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code>（默认值）</td><td><code>/logo.svg</code></td></tr><tr><td><code>&quot;/assets&quot;</code></td><td><code>/assets/logo.svg</code></td></tr><tr><td><code>&quot;https://cdn.example.com/&quot;</code></td><td><code>https://cdn.example.com/logo.svg</code></td></tr></tbody></table><blockquote><p>复制文件的位置和文件名由<a href="/bundler/#naming"><code>naming.asset</code></a>的值确定。</p></blockquote><p>此加载器将按原样复制到<code>outdir</code>。复制文件的名称由<code>naming.asset</code>的值确定。</p><p>如果使用 TypeScript，可能会出现以下错误：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// TypeScript错误</span></span>
<span class="line"><span style="color:#6A737D;">// 找不到模块“./logo.svg”或其对应的类型声明。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// TypeScript错误</span></span>
<span class="line"><span style="color:#6A737D;">// 找不到模块“./logo.svg”或其对应的类型声明。</span></span></code></pre></div><p>可以通过在项目中的任何位置创建<code>*.d.ts</code>文件（任何名称都可以）并使用以下内容来修复此错误：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">declare</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">module</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;*.svg&quot;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">content</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> content;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">declare</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">module</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;*.svg&quot;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">content</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> content;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这告诉 TypeScript，从<code>.svg</code>导入的任何默认导入应该被视为字符串。</p>`,65),e=[p];function t(c,r,d,i,y,E){return o(),a("div",null,e)}const h=s(l,[["render",t]]);export{u as __pageData,h as default};
